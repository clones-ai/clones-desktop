import 'package:clones_desktop/domain/models/agent/agent_legal.dart';
import 'package:clones_desktop/domain/models/agent/agent_tokenomics.dart';
import 'package:clones_desktop/domain/models/agent/agent_transaction.dart';
import 'package:clones_desktop/domain/models/agent/gym_agent.dart';
import 'package:clones_desktop/domain/models/api/api_error.dart';
import 'package:clones_desktop/domain/models/api/request_options.dart';
import 'package:clones_desktop/utils/api_client.dart';

class AgentRepositoryImpl {
  AgentRepositoryImpl(this._client);
  final ApiClient _client;

  /// Create a new agent
  Future<GymAgent> createAgent({
    required String poolId,
    required String agentName,
    required String ticker,
    required String description,
    String? logoUrl,
    required AgentTokenomics tokenomics,
    required AgentLegal legal,
    String? customUrl,
    String? huggingFaceApiKey,
  }) async {
    try {
      final data = {
        'pool_id': poolId,
        'name': agentName,
        'ticker': ticker,
        'description': description,
        'tokenomics': {
          'supply': tokenomics.supply,
          'minLiquiditySol': tokenomics.minLiquiditySol,
          'gatedPercentage': tokenomics.gatedPercentage,
        },
        'legal': {
          'autoGeneratedTerms': legal.autoGeneratedTerms,
          'termsUrl': legal.termsUrl,
        },
      };

      if (logoUrl != null) data['logoUrl'] = logoUrl;
      if (customUrl != null) {
        data['deployment'] = <String, dynamic>{'customUrl': customUrl};
      }
      if (huggingFaceApiKey != null) {
        final currentDeployment = data['deployment'] is Map<String, dynamic>
            ? data['deployment']! as Map<String, dynamic>
            : <String, dynamic>{};
        data['deployment'] = <String, dynamic>{
          ...currentDeployment,
          'huggingFaceApiKey': huggingFaceApiKey,
        };
      }

      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents',
        data: data,
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create agent: $e');
    }
  }

  /// Get agent by pool ID
  Future<GymAgent?> getAgentByPoolId(String poolId) async {
    try {
      final response = await _client.get<Map<String, dynamic>?>(
        '/forge/agents/pool/$poolId',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>?,
      );
      if (response == null) {
        return null;
      }
      return GymAgent.fromJson(response);
    } catch (e) {
      // An error (like 404) can mean no agent exists, which is a valid case.
      if (e is ApiError && e.status == 404) {
        return null;
      }
      throw Exception('Failed to get agent by pool ID: $e');
    }
  }

  /// List all agents owned by the authenticated user
  Future<List<GymAgent>> listAgents() async {
    try {
      final data = await _client.get<List<dynamic>>(
        '/forge/agents',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as List<dynamic>,
      );

      return data
          .map((agent) => GymAgent.fromJson(agent as Map<String, dynamic>))
          .toList();
    } catch (e) {
      throw Exception('Failed to load agents: $e');
    }
  }

  /// Update agent details
  Future<GymAgent> updateAgent({
    required String agentId,
    String? agentName,
    String? description,
    String? logoUrl,
    String? customUrl,
    String? huggingFaceApiKey,
  }) async {
    try {
      final data = <String, dynamic>{};

      if (agentName != null) data['name'] = agentName;
      if (description != null) data['description'] = description;
      if (logoUrl != null) data['logoUrl'] = logoUrl;
      if (customUrl != null) {
        data['deployment'] = <String, dynamic>{'customUrl': customUrl};
      }
      if (huggingFaceApiKey != null) {
        final currentDeployment = data['deployment'] is Map<String, dynamic>
            ? data['deployment'] as Map<String, dynamic>
            : <String, dynamic>{};
        data['deployment'] = <String, dynamic>{
          ...currentDeployment,
          'huggingFaceApiKey': huggingFaceApiKey,
        };
      }

      final response = await _client.put<Map<String, dynamic>>(
        '/forge/agents/$agentId',
        data: data,
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update agent: $e');
    }
  }

  /// Initiate deployment
  Future<GymAgent> deployAgent(String agentId) async {
    try {
      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents/$agentId/deploy',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to deploy agent: $e');
    }
  }

  /// Cancel deployment
  Future<GymAgent> cancelDeployment(String agentId) async {
    try {
      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents/$agentId/cancel',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to cancel deployment: $e');
    }
  }

  /// Retry failed deployment
  Future<GymAgent> retryDeployment(String agentId) async {
    try {
      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents/$agentId/retry-deployment',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to retry deployment: $e');
    }
  }

  /// Deactivate agent
  Future<GymAgent> deactivateAgent(String agentId) async {
    try {
      final response = await _client.patch<Map<String, dynamic>>(
        '/forge/agents/$agentId/status',
        data: {'status': 'DEACTIVATED'},
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to deactivate agent: $e');
    }
  }

  /// Archive agent (soft delete)
  Future<GymAgent> archiveAgent(String agentId) async {
    try {
      final response = await _client.delete<Map<String, dynamic>>(
        '/forge/agents/$agentId',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to archive agent: $e');
    }
  }

  /// Get unsigned transaction for token creation or pool creation
  Future<UnsignedTransaction> getUnsignedTransaction({
    required String agentId,
    required AgentTransactionType type,
  }) async {
    try {
      final typeString = type == AgentTransactionType.tokenCreation
          ? 'token-creation'
          : 'pool-creation';

      final response = await _client.get<Map<String, dynamic>>(
        '/forge/agents/$agentId/transactions/$typeString',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return UnsignedTransaction.fromJson(response);
    } catch (e) {
      throw Exception('Failed to get unsigned transaction: $e');
    }
  }

  /// Submit signed transaction
  Future<SubmitTxResponse> submitTransaction({
    required String agentId,
    required AgentTransactionType type,
    required String signedTransaction,
    required String idempotencyKey,
  }) async {
    try {
      final data = {
        'type': type.jsonValue,
        'signedTransaction': signedTransaction,
        'idempotencyKey': idempotencyKey,
      };

      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents/$agentId/submit-tx',
        data: data,
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return SubmitTxResponse.fromJson(response);
    } catch (e) {
      throw Exception('Failed to submit transaction: $e');
    }
  }

  /// Add new agent version
  Future<GymAgent> addAgentVersion({
    required String agentId,
    required String versionTag,
    String? customUrl,
    String? huggingFaceApiKey,
  }) async {
    try {
      final data = <String, dynamic>{
        'versionTag': versionTag,
      };

      if (customUrl != null) data['customUrl'] = customUrl;
      if (huggingFaceApiKey != null) {
        data['huggingFaceApiKey'] = huggingFaceApiKey;
      }

      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents/$agentId/versions',
        data: data,
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to add agent version: $e');
    }
  }

  /// Set active agent version
  Future<GymAgent> setActiveVersion({
    required String agentId,
    required String versionTag,
  }) async {
    try {
      final response = await _client.put<Map<String, dynamic>>(
        '/forge/agents/$agentId/versions/active',
        data: {'versionTag': versionTag},
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to set active version: $e');
    }
  }

  /// Get agent health
  Future<AgentHealth> getAgentHealth(String agentId) async {
    try {
      final response = await _client.get<Map<String, dynamic>>(
        '/forge/agents/$agentId/health',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return AgentHealth.fromJson(response);
    } catch (e) {
      throw Exception('Failed to get agent health: $e');
    }
  }

  /// Get agent metrics
  Future<AgentMetrics> getAgentMetrics({
    required String agentId,
    String? timeframe,
    String? versionTag,
  }) async {
    try {
      final params = <String, dynamic>{};
      if (timeframe != null) params['timeframe'] = timeframe;
      if (versionTag != null) params['versionTag'] = versionTag;

      final response = await _client.get<Map<String, dynamic>>(
        '/forge/agents/$agentId/metrics',
        params: params,
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return AgentMetrics.fromJson(response);
    } catch (e) {
      throw Exception('Failed to get agent metrics: $e');
    }
  }

  /// Search public agents (marketplace)
  Future<AgentSearchResponse> searchAgents({
    String? query,
    String? sortBy,
    int? limit,
    int? offset,
  }) async {
    try {
      final params = <String, dynamic>{};
      if (query != null) params['q'] = query;
      if (sortBy != null) params['sortBy'] = sortBy;
      if (limit != null) params['limit'] = limit;
      if (offset != null) params['offset'] = offset;

      final response = await _client.get<Map<String, dynamic>>(
        '/forge/agents/search',
        params: params,
        fromJson: (json) => json as Map<String, dynamic>,
      );

      return AgentSearchResponse.fromJson(response);
    } catch (e) {
      throw Exception('Failed to search agents: $e');
    }
  }

  /// Initiate deployment process
  Future<GymAgent> initiateDeployment(String agentId) async {
    try {
      final response = await _client.post<Map<String, dynamic>>(
        '/forge/agents/$agentId/deploy',
        options: const RequestOptions(requiresAuth: true),
        fromJson: (json) => json as Map<String, dynamic>,
      );
      return GymAgent.fromJson(response);
    } catch (e) {
      throw Exception('Failed to initiate deployment: $e');
    }
  }
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'gas.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

GasEstimate _$GasEstimateFromJson(Map<String, dynamic> json) {
  return _GasEstimate.fromJson(json);
}

/// @nodoc
mixin _$GasEstimate {
  String get gasLimit => throw _privateConstructorUsedError;
  String get maxFeePerGas => throw _privateConstructorUsedError;
  String get maxPriorityFeePerGas => throw _privateConstructorUsedError;
  String get totalGasCost => throw _privateConstructorUsedError;
  String get totalGasCostEth => throw _privateConstructorUsedError;
  double get totalGasCostUsd => throw _privateConstructorUsedError;

  /// Serializes this GasEstimate to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GasEstimate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GasEstimateCopyWith<GasEstimate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GasEstimateCopyWith<$Res> {
  factory $GasEstimateCopyWith(
          GasEstimate value, $Res Function(GasEstimate) then) =
      _$GasEstimateCopyWithImpl<$Res, GasEstimate>;
  @useResult
  $Res call(
      {String gasLimit,
      String maxFeePerGas,
      String maxPriorityFeePerGas,
      String totalGasCost,
      String totalGasCostEth,
      double totalGasCostUsd});
}

/// @nodoc
class _$GasEstimateCopyWithImpl<$Res, $Val extends GasEstimate>
    implements $GasEstimateCopyWith<$Res> {
  _$GasEstimateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GasEstimate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? gasLimit = null,
    Object? maxFeePerGas = null,
    Object? maxPriorityFeePerGas = null,
    Object? totalGasCost = null,
    Object? totalGasCostEth = null,
    Object? totalGasCostUsd = null,
  }) {
    return _then(_value.copyWith(
      gasLimit: null == gasLimit
          ? _value.gasLimit
          : gasLimit // ignore: cast_nullable_to_non_nullable
              as String,
      maxFeePerGas: null == maxFeePerGas
          ? _value.maxFeePerGas
          : maxFeePerGas // ignore: cast_nullable_to_non_nullable
              as String,
      maxPriorityFeePerGas: null == maxPriorityFeePerGas
          ? _value.maxPriorityFeePerGas
          : maxPriorityFeePerGas // ignore: cast_nullable_to_non_nullable
              as String,
      totalGasCost: null == totalGasCost
          ? _value.totalGasCost
          : totalGasCost // ignore: cast_nullable_to_non_nullable
              as String,
      totalGasCostEth: null == totalGasCostEth
          ? _value.totalGasCostEth
          : totalGasCostEth // ignore: cast_nullable_to_non_nullable
              as String,
      totalGasCostUsd: null == totalGasCostUsd
          ? _value.totalGasCostUsd
          : totalGasCostUsd // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GasEstimateImplCopyWith<$Res>
    implements $GasEstimateCopyWith<$Res> {
  factory _$$GasEstimateImplCopyWith(
          _$GasEstimateImpl value, $Res Function(_$GasEstimateImpl) then) =
      __$$GasEstimateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String gasLimit,
      String maxFeePerGas,
      String maxPriorityFeePerGas,
      String totalGasCost,
      String totalGasCostEth,
      double totalGasCostUsd});
}

/// @nodoc
class __$$GasEstimateImplCopyWithImpl<$Res>
    extends _$GasEstimateCopyWithImpl<$Res, _$GasEstimateImpl>
    implements _$$GasEstimateImplCopyWith<$Res> {
  __$$GasEstimateImplCopyWithImpl(
      _$GasEstimateImpl _value, $Res Function(_$GasEstimateImpl) _then)
      : super(_value, _then);

  /// Create a copy of GasEstimate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? gasLimit = null,
    Object? maxFeePerGas = null,
    Object? maxPriorityFeePerGas = null,
    Object? totalGasCost = null,
    Object? totalGasCostEth = null,
    Object? totalGasCostUsd = null,
  }) {
    return _then(_$GasEstimateImpl(
      gasLimit: null == gasLimit
          ? _value.gasLimit
          : gasLimit // ignore: cast_nullable_to_non_nullable
              as String,
      maxFeePerGas: null == maxFeePerGas
          ? _value.maxFeePerGas
          : maxFeePerGas // ignore: cast_nullable_to_non_nullable
              as String,
      maxPriorityFeePerGas: null == maxPriorityFeePerGas
          ? _value.maxPriorityFeePerGas
          : maxPriorityFeePerGas // ignore: cast_nullable_to_non_nullable
              as String,
      totalGasCost: null == totalGasCost
          ? _value.totalGasCost
          : totalGasCost // ignore: cast_nullable_to_non_nullable
              as String,
      totalGasCostEth: null == totalGasCostEth
          ? _value.totalGasCostEth
          : totalGasCostEth // ignore: cast_nullable_to_non_nullable
              as String,
      totalGasCostUsd: null == totalGasCostUsd
          ? _value.totalGasCostUsd
          : totalGasCostUsd // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GasEstimateImpl implements _GasEstimate {
  const _$GasEstimateImpl(
      {required this.gasLimit,
      required this.maxFeePerGas,
      required this.maxPriorityFeePerGas,
      required this.totalGasCost,
      required this.totalGasCostEth,
      required this.totalGasCostUsd});

  factory _$GasEstimateImpl.fromJson(Map<String, dynamic> json) =>
      _$$GasEstimateImplFromJson(json);

  @override
  final String gasLimit;
  @override
  final String maxFeePerGas;
  @override
  final String maxPriorityFeePerGas;
  @override
  final String totalGasCost;
  @override
  final String totalGasCostEth;
  @override
  final double totalGasCostUsd;

  @override
  String toString() {
    return 'GasEstimate(gasLimit: $gasLimit, maxFeePerGas: $maxFeePerGas, maxPriorityFeePerGas: $maxPriorityFeePerGas, totalGasCost: $totalGasCost, totalGasCostEth: $totalGasCostEth, totalGasCostUsd: $totalGasCostUsd)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GasEstimateImpl &&
            (identical(other.gasLimit, gasLimit) ||
                other.gasLimit == gasLimit) &&
            (identical(other.maxFeePerGas, maxFeePerGas) ||
                other.maxFeePerGas == maxFeePerGas) &&
            (identical(other.maxPriorityFeePerGas, maxPriorityFeePerGas) ||
                other.maxPriorityFeePerGas == maxPriorityFeePerGas) &&
            (identical(other.totalGasCost, totalGasCost) ||
                other.totalGasCost == totalGasCost) &&
            (identical(other.totalGasCostEth, totalGasCostEth) ||
                other.totalGasCostEth == totalGasCostEth) &&
            (identical(other.totalGasCostUsd, totalGasCostUsd) ||
                other.totalGasCostUsd == totalGasCostUsd));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, gasLimit, maxFeePerGas,
      maxPriorityFeePerGas, totalGasCost, totalGasCostEth, totalGasCostUsd);

  /// Create a copy of GasEstimate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GasEstimateImplCopyWith<_$GasEstimateImpl> get copyWith =>
      __$$GasEstimateImplCopyWithImpl<_$GasEstimateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GasEstimateImplToJson(
      this,
    );
  }
}

abstract class _GasEstimate implements GasEstimate {
  const factory _GasEstimate(
      {required final String gasLimit,
      required final String maxFeePerGas,
      required final String maxPriorityFeePerGas,
      required final String totalGasCost,
      required final String totalGasCostEth,
      required final double totalGasCostUsd}) = _$GasEstimateImpl;

  factory _GasEstimate.fromJson(Map<String, dynamic> json) =
      _$GasEstimateImpl.fromJson;

  @override
  String get gasLimit;
  @override
  String get maxFeePerGas;
  @override
  String get maxPriorityFeePerGas;
  @override
  String get totalGasCost;
  @override
  String get totalGasCostEth;
  @override
  double get totalGasCostUsd;

  /// Create a copy of GasEstimate
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GasEstimateImplCopyWith<_$GasEstimateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GasAnalysis _$GasAnalysisFromJson(Map<String, dynamic> json) {
  return _GasAnalysis.fromJson(json);
}

/// @nodoc
mixin _$GasAnalysis {
  GasEstimate get estimatedGas => throw _privateConstructorUsedError;
  String get netReward => throw _privateConstructorUsedError;
  double get netRewardUsd => throw _privateConstructorUsedError;
  double get gasCostVsReward => throw _privateConstructorUsedError;
  bool get shouldWarn => throw _privateConstructorUsedError;
  String get recommendation => throw _privateConstructorUsedError;

  /// Serializes this GasAnalysis to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GasAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GasAnalysisCopyWith<GasAnalysis> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GasAnalysisCopyWith<$Res> {
  factory $GasAnalysisCopyWith(
          GasAnalysis value, $Res Function(GasAnalysis) then) =
      _$GasAnalysisCopyWithImpl<$Res, GasAnalysis>;
  @useResult
  $Res call(
      {GasEstimate estimatedGas,
      String netReward,
      double netRewardUsd,
      double gasCostVsReward,
      bool shouldWarn,
      String recommendation});

  $GasEstimateCopyWith<$Res> get estimatedGas;
}

/// @nodoc
class _$GasAnalysisCopyWithImpl<$Res, $Val extends GasAnalysis>
    implements $GasAnalysisCopyWith<$Res> {
  _$GasAnalysisCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GasAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? estimatedGas = null,
    Object? netReward = null,
    Object? netRewardUsd = null,
    Object? gasCostVsReward = null,
    Object? shouldWarn = null,
    Object? recommendation = null,
  }) {
    return _then(_value.copyWith(
      estimatedGas: null == estimatedGas
          ? _value.estimatedGas
          : estimatedGas // ignore: cast_nullable_to_non_nullable
              as GasEstimate,
      netReward: null == netReward
          ? _value.netReward
          : netReward // ignore: cast_nullable_to_non_nullable
              as String,
      netRewardUsd: null == netRewardUsd
          ? _value.netRewardUsd
          : netRewardUsd // ignore: cast_nullable_to_non_nullable
              as double,
      gasCostVsReward: null == gasCostVsReward
          ? _value.gasCostVsReward
          : gasCostVsReward // ignore: cast_nullable_to_non_nullable
              as double,
      shouldWarn: null == shouldWarn
          ? _value.shouldWarn
          : shouldWarn // ignore: cast_nullable_to_non_nullable
              as bool,
      recommendation: null == recommendation
          ? _value.recommendation
          : recommendation // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  /// Create a copy of GasAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GasEstimateCopyWith<$Res> get estimatedGas {
    return $GasEstimateCopyWith<$Res>(_value.estimatedGas, (value) {
      return _then(_value.copyWith(estimatedGas: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GasAnalysisImplCopyWith<$Res>
    implements $GasAnalysisCopyWith<$Res> {
  factory _$$GasAnalysisImplCopyWith(
          _$GasAnalysisImpl value, $Res Function(_$GasAnalysisImpl) then) =
      __$$GasAnalysisImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {GasEstimate estimatedGas,
      String netReward,
      double netRewardUsd,
      double gasCostVsReward,
      bool shouldWarn,
      String recommendation});

  @override
  $GasEstimateCopyWith<$Res> get estimatedGas;
}

/// @nodoc
class __$$GasAnalysisImplCopyWithImpl<$Res>
    extends _$GasAnalysisCopyWithImpl<$Res, _$GasAnalysisImpl>
    implements _$$GasAnalysisImplCopyWith<$Res> {
  __$$GasAnalysisImplCopyWithImpl(
      _$GasAnalysisImpl _value, $Res Function(_$GasAnalysisImpl) _then)
      : super(_value, _then);

  /// Create a copy of GasAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? estimatedGas = null,
    Object? netReward = null,
    Object? netRewardUsd = null,
    Object? gasCostVsReward = null,
    Object? shouldWarn = null,
    Object? recommendation = null,
  }) {
    return _then(_$GasAnalysisImpl(
      estimatedGas: null == estimatedGas
          ? _value.estimatedGas
          : estimatedGas // ignore: cast_nullable_to_non_nullable
              as GasEstimate,
      netReward: null == netReward
          ? _value.netReward
          : netReward // ignore: cast_nullable_to_non_nullable
              as String,
      netRewardUsd: null == netRewardUsd
          ? _value.netRewardUsd
          : netRewardUsd // ignore: cast_nullable_to_non_nullable
              as double,
      gasCostVsReward: null == gasCostVsReward
          ? _value.gasCostVsReward
          : gasCostVsReward // ignore: cast_nullable_to_non_nullable
              as double,
      shouldWarn: null == shouldWarn
          ? _value.shouldWarn
          : shouldWarn // ignore: cast_nullable_to_non_nullable
              as bool,
      recommendation: null == recommendation
          ? _value.recommendation
          : recommendation // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GasAnalysisImpl implements _GasAnalysis {
  const _$GasAnalysisImpl(
      {required this.estimatedGas,
      required this.netReward,
      required this.netRewardUsd,
      required this.gasCostVsReward,
      required this.shouldWarn,
      required this.recommendation});

  factory _$GasAnalysisImpl.fromJson(Map<String, dynamic> json) =>
      _$$GasAnalysisImplFromJson(json);

  @override
  final GasEstimate estimatedGas;
  @override
  final String netReward;
  @override
  final double netRewardUsd;
  @override
  final double gasCostVsReward;
  @override
  final bool shouldWarn;
  @override
  final String recommendation;

  @override
  String toString() {
    return 'GasAnalysis(estimatedGas: $estimatedGas, netReward: $netReward, netRewardUsd: $netRewardUsd, gasCostVsReward: $gasCostVsReward, shouldWarn: $shouldWarn, recommendation: $recommendation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GasAnalysisImpl &&
            (identical(other.estimatedGas, estimatedGas) ||
                other.estimatedGas == estimatedGas) &&
            (identical(other.netReward, netReward) ||
                other.netReward == netReward) &&
            (identical(other.netRewardUsd, netRewardUsd) ||
                other.netRewardUsd == netRewardUsd) &&
            (identical(other.gasCostVsReward, gasCostVsReward) ||
                other.gasCostVsReward == gasCostVsReward) &&
            (identical(other.shouldWarn, shouldWarn) ||
                other.shouldWarn == shouldWarn) &&
            (identical(other.recommendation, recommendation) ||
                other.recommendation == recommendation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, estimatedGas, netReward,
      netRewardUsd, gasCostVsReward, shouldWarn, recommendation);

  /// Create a copy of GasAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GasAnalysisImplCopyWith<_$GasAnalysisImpl> get copyWith =>
      __$$GasAnalysisImplCopyWithImpl<_$GasAnalysisImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GasAnalysisImplToJson(
      this,
    );
  }
}

abstract class _GasAnalysis implements GasAnalysis {
  const factory _GasAnalysis(
      {required final GasEstimate estimatedGas,
      required final String netReward,
      required final double netRewardUsd,
      required final double gasCostVsReward,
      required final bool shouldWarn,
      required final String recommendation}) = _$GasAnalysisImpl;

  factory _GasAnalysis.fromJson(Map<String, dynamic> json) =
      _$GasAnalysisImpl.fromJson;

  @override
  GasEstimate get estimatedGas;
  @override
  String get netReward;
  @override
  double get netRewardUsd;
  @override
  double get gasCostVsReward;
  @override
  bool get shouldWarn;
  @override
  String get recommendation;

  /// Create a copy of GasAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GasAnalysisImplCopyWith<_$GasAnalysisImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BatchOptimization _$BatchOptimizationFromJson(Map<String, dynamic> json) {
  return _BatchOptimization.fromJson(json);
}

/// @nodoc
mixin _$BatchOptimization {
  List<ClaimData> get originalClaims => throw _privateConstructorUsedError;
  List<List<ClaimData>> get optimizedBatches =>
      throw _privateConstructorUsedError;
  String get totalGasSavings => throw _privateConstructorUsedError;
  double get savingsPercentage => throw _privateConstructorUsedError;
  String get recommendation => throw _privateConstructorUsedError;

  /// Serializes this BatchOptimization to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of BatchOptimization
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BatchOptimizationCopyWith<BatchOptimization> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BatchOptimizationCopyWith<$Res> {
  factory $BatchOptimizationCopyWith(
          BatchOptimization value, $Res Function(BatchOptimization) then) =
      _$BatchOptimizationCopyWithImpl<$Res, BatchOptimization>;
  @useResult
  $Res call(
      {List<ClaimData> originalClaims,
      List<List<ClaimData>> optimizedBatches,
      String totalGasSavings,
      double savingsPercentage,
      String recommendation});
}

/// @nodoc
class _$BatchOptimizationCopyWithImpl<$Res, $Val extends BatchOptimization>
    implements $BatchOptimizationCopyWith<$Res> {
  _$BatchOptimizationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BatchOptimization
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? originalClaims = null,
    Object? optimizedBatches = null,
    Object? totalGasSavings = null,
    Object? savingsPercentage = null,
    Object? recommendation = null,
  }) {
    return _then(_value.copyWith(
      originalClaims: null == originalClaims
          ? _value.originalClaims
          : originalClaims // ignore: cast_nullable_to_non_nullable
              as List<ClaimData>,
      optimizedBatches: null == optimizedBatches
          ? _value.optimizedBatches
          : optimizedBatches // ignore: cast_nullable_to_non_nullable
              as List<List<ClaimData>>,
      totalGasSavings: null == totalGasSavings
          ? _value.totalGasSavings
          : totalGasSavings // ignore: cast_nullable_to_non_nullable
              as String,
      savingsPercentage: null == savingsPercentage
          ? _value.savingsPercentage
          : savingsPercentage // ignore: cast_nullable_to_non_nullable
              as double,
      recommendation: null == recommendation
          ? _value.recommendation
          : recommendation // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BatchOptimizationImplCopyWith<$Res>
    implements $BatchOptimizationCopyWith<$Res> {
  factory _$$BatchOptimizationImplCopyWith(_$BatchOptimizationImpl value,
          $Res Function(_$BatchOptimizationImpl) then) =
      __$$BatchOptimizationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<ClaimData> originalClaims,
      List<List<ClaimData>> optimizedBatches,
      String totalGasSavings,
      double savingsPercentage,
      String recommendation});
}

/// @nodoc
class __$$BatchOptimizationImplCopyWithImpl<$Res>
    extends _$BatchOptimizationCopyWithImpl<$Res, _$BatchOptimizationImpl>
    implements _$$BatchOptimizationImplCopyWith<$Res> {
  __$$BatchOptimizationImplCopyWithImpl(_$BatchOptimizationImpl _value,
      $Res Function(_$BatchOptimizationImpl) _then)
      : super(_value, _then);

  /// Create a copy of BatchOptimization
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? originalClaims = null,
    Object? optimizedBatches = null,
    Object? totalGasSavings = null,
    Object? savingsPercentage = null,
    Object? recommendation = null,
  }) {
    return _then(_$BatchOptimizationImpl(
      originalClaims: null == originalClaims
          ? _value._originalClaims
          : originalClaims // ignore: cast_nullable_to_non_nullable
              as List<ClaimData>,
      optimizedBatches: null == optimizedBatches
          ? _value._optimizedBatches
          : optimizedBatches // ignore: cast_nullable_to_non_nullable
              as List<List<ClaimData>>,
      totalGasSavings: null == totalGasSavings
          ? _value.totalGasSavings
          : totalGasSavings // ignore: cast_nullable_to_non_nullable
              as String,
      savingsPercentage: null == savingsPercentage
          ? _value.savingsPercentage
          : savingsPercentage // ignore: cast_nullable_to_non_nullable
              as double,
      recommendation: null == recommendation
          ? _value.recommendation
          : recommendation // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BatchOptimizationImpl implements _BatchOptimization {
  const _$BatchOptimizationImpl(
      {required final List<ClaimData> originalClaims,
      required final List<List<ClaimData>> optimizedBatches,
      required this.totalGasSavings,
      required this.savingsPercentage,
      required this.recommendation})
      : _originalClaims = originalClaims,
        _optimizedBatches = optimizedBatches;

  factory _$BatchOptimizationImpl.fromJson(Map<String, dynamic> json) =>
      _$$BatchOptimizationImplFromJson(json);

  final List<ClaimData> _originalClaims;
  @override
  List<ClaimData> get originalClaims {
    if (_originalClaims is EqualUnmodifiableListView) return _originalClaims;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_originalClaims);
  }

  final List<List<ClaimData>> _optimizedBatches;
  @override
  List<List<ClaimData>> get optimizedBatches {
    if (_optimizedBatches is EqualUnmodifiableListView)
      return _optimizedBatches;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_optimizedBatches);
  }

  @override
  final String totalGasSavings;
  @override
  final double savingsPercentage;
  @override
  final String recommendation;

  @override
  String toString() {
    return 'BatchOptimization(originalClaims: $originalClaims, optimizedBatches: $optimizedBatches, totalGasSavings: $totalGasSavings, savingsPercentage: $savingsPercentage, recommendation: $recommendation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BatchOptimizationImpl &&
            const DeepCollectionEquality()
                .equals(other._originalClaims, _originalClaims) &&
            const DeepCollectionEquality()
                .equals(other._optimizedBatches, _optimizedBatches) &&
            (identical(other.totalGasSavings, totalGasSavings) ||
                other.totalGasSavings == totalGasSavings) &&
            (identical(other.savingsPercentage, savingsPercentage) ||
                other.savingsPercentage == savingsPercentage) &&
            (identical(other.recommendation, recommendation) ||
                other.recommendation == recommendation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_originalClaims),
      const DeepCollectionEquality().hash(_optimizedBatches),
      totalGasSavings,
      savingsPercentage,
      recommendation);

  /// Create a copy of BatchOptimization
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BatchOptimizationImplCopyWith<_$BatchOptimizationImpl> get copyWith =>
      __$$BatchOptimizationImplCopyWithImpl<_$BatchOptimizationImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BatchOptimizationImplToJson(
      this,
    );
  }
}

abstract class _BatchOptimization implements BatchOptimization {
  const factory _BatchOptimization(
      {required final List<ClaimData> originalClaims,
      required final List<List<ClaimData>> optimizedBatches,
      required final String totalGasSavings,
      required final double savingsPercentage,
      required final String recommendation}) = _$BatchOptimizationImpl;

  factory _BatchOptimization.fromJson(Map<String, dynamic> json) =
      _$BatchOptimizationImpl.fromJson;

  @override
  List<ClaimData> get originalClaims;
  @override
  List<List<ClaimData>> get optimizedBatches;
  @override
  String get totalGasSavings;
  @override
  double get savingsPercentage;
  @override
  String get recommendation;

  /// Create a copy of BatchOptimization
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BatchOptimizationImplCopyWith<_$BatchOptimizationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GasPriceAdvice _$GasPriceAdviceFromJson(Map<String, dynamic> json) {
  return _GasPriceAdvice.fromJson(json);
}

/// @nodoc
mixin _$GasPriceAdvice {
  String get currentGasPrice => throw _privateConstructorUsedError;
  double get gasPriceGwei => throw _privateConstructorUsedError;
  String get gasPriceLevel =>
      throw _privateConstructorUsedError; // 'low', 'medium', 'high', 'very-high'
  String get recommendation => throw _privateConstructorUsedError;
  String? get suggestedWaitTime => throw _privateConstructorUsedError;

  /// Serializes this GasPriceAdvice to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GasPriceAdvice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GasPriceAdviceCopyWith<GasPriceAdvice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GasPriceAdviceCopyWith<$Res> {
  factory $GasPriceAdviceCopyWith(
          GasPriceAdvice value, $Res Function(GasPriceAdvice) then) =
      _$GasPriceAdviceCopyWithImpl<$Res, GasPriceAdvice>;
  @useResult
  $Res call(
      {String currentGasPrice,
      double gasPriceGwei,
      String gasPriceLevel,
      String recommendation,
      String? suggestedWaitTime});
}

/// @nodoc
class _$GasPriceAdviceCopyWithImpl<$Res, $Val extends GasPriceAdvice>
    implements $GasPriceAdviceCopyWith<$Res> {
  _$GasPriceAdviceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GasPriceAdvice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentGasPrice = null,
    Object? gasPriceGwei = null,
    Object? gasPriceLevel = null,
    Object? recommendation = null,
    Object? suggestedWaitTime = freezed,
  }) {
    return _then(_value.copyWith(
      currentGasPrice: null == currentGasPrice
          ? _value.currentGasPrice
          : currentGasPrice // ignore: cast_nullable_to_non_nullable
              as String,
      gasPriceGwei: null == gasPriceGwei
          ? _value.gasPriceGwei
          : gasPriceGwei // ignore: cast_nullable_to_non_nullable
              as double,
      gasPriceLevel: null == gasPriceLevel
          ? _value.gasPriceLevel
          : gasPriceLevel // ignore: cast_nullable_to_non_nullable
              as String,
      recommendation: null == recommendation
          ? _value.recommendation
          : recommendation // ignore: cast_nullable_to_non_nullable
              as String,
      suggestedWaitTime: freezed == suggestedWaitTime
          ? _value.suggestedWaitTime
          : suggestedWaitTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GasPriceAdviceImplCopyWith<$Res>
    implements $GasPriceAdviceCopyWith<$Res> {
  factory _$$GasPriceAdviceImplCopyWith(_$GasPriceAdviceImpl value,
          $Res Function(_$GasPriceAdviceImpl) then) =
      __$$GasPriceAdviceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String currentGasPrice,
      double gasPriceGwei,
      String gasPriceLevel,
      String recommendation,
      String? suggestedWaitTime});
}

/// @nodoc
class __$$GasPriceAdviceImplCopyWithImpl<$Res>
    extends _$GasPriceAdviceCopyWithImpl<$Res, _$GasPriceAdviceImpl>
    implements _$$GasPriceAdviceImplCopyWith<$Res> {
  __$$GasPriceAdviceImplCopyWithImpl(
      _$GasPriceAdviceImpl _value, $Res Function(_$GasPriceAdviceImpl) _then)
      : super(_value, _then);

  /// Create a copy of GasPriceAdvice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentGasPrice = null,
    Object? gasPriceGwei = null,
    Object? gasPriceLevel = null,
    Object? recommendation = null,
    Object? suggestedWaitTime = freezed,
  }) {
    return _then(_$GasPriceAdviceImpl(
      currentGasPrice: null == currentGasPrice
          ? _value.currentGasPrice
          : currentGasPrice // ignore: cast_nullable_to_non_nullable
              as String,
      gasPriceGwei: null == gasPriceGwei
          ? _value.gasPriceGwei
          : gasPriceGwei // ignore: cast_nullable_to_non_nullable
              as double,
      gasPriceLevel: null == gasPriceLevel
          ? _value.gasPriceLevel
          : gasPriceLevel // ignore: cast_nullable_to_non_nullable
              as String,
      recommendation: null == recommendation
          ? _value.recommendation
          : recommendation // ignore: cast_nullable_to_non_nullable
              as String,
      suggestedWaitTime: freezed == suggestedWaitTime
          ? _value.suggestedWaitTime
          : suggestedWaitTime // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GasPriceAdviceImpl implements _GasPriceAdvice {
  const _$GasPriceAdviceImpl(
      {required this.currentGasPrice,
      required this.gasPriceGwei,
      required this.gasPriceLevel,
      required this.recommendation,
      this.suggestedWaitTime});

  factory _$GasPriceAdviceImpl.fromJson(Map<String, dynamic> json) =>
      _$$GasPriceAdviceImplFromJson(json);

  @override
  final String currentGasPrice;
  @override
  final double gasPriceGwei;
  @override
  final String gasPriceLevel;
// 'low', 'medium', 'high', 'very-high'
  @override
  final String recommendation;
  @override
  final String? suggestedWaitTime;

  @override
  String toString() {
    return 'GasPriceAdvice(currentGasPrice: $currentGasPrice, gasPriceGwei: $gasPriceGwei, gasPriceLevel: $gasPriceLevel, recommendation: $recommendation, suggestedWaitTime: $suggestedWaitTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GasPriceAdviceImpl &&
            (identical(other.currentGasPrice, currentGasPrice) ||
                other.currentGasPrice == currentGasPrice) &&
            (identical(other.gasPriceGwei, gasPriceGwei) ||
                other.gasPriceGwei == gasPriceGwei) &&
            (identical(other.gasPriceLevel, gasPriceLevel) ||
                other.gasPriceLevel == gasPriceLevel) &&
            (identical(other.recommendation, recommendation) ||
                other.recommendation == recommendation) &&
            (identical(other.suggestedWaitTime, suggestedWaitTime) ||
                other.suggestedWaitTime == suggestedWaitTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, currentGasPrice, gasPriceGwei,
      gasPriceLevel, recommendation, suggestedWaitTime);

  /// Create a copy of GasPriceAdvice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GasPriceAdviceImplCopyWith<_$GasPriceAdviceImpl> get copyWith =>
      __$$GasPriceAdviceImplCopyWithImpl<_$GasPriceAdviceImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GasPriceAdviceImplToJson(
      this,
    );
  }
}

abstract class _GasPriceAdvice implements GasPriceAdvice {
  const factory _GasPriceAdvice(
      {required final String currentGasPrice,
      required final double gasPriceGwei,
      required final String gasPriceLevel,
      required final String recommendation,
      final String? suggestedWaitTime}) = _$GasPriceAdviceImpl;

  factory _GasPriceAdvice.fromJson(Map<String, dynamic> json) =
      _$GasPriceAdviceImpl.fromJson;

  @override
  String get currentGasPrice;
  @override
  double get gasPriceGwei;
  @override
  String get gasPriceLevel; // 'low', 'medium', 'high', 'very-high'
  @override
  String get recommendation;
  @override
  String? get suggestedWaitTime;

  /// Create a copy of GasPriceAdvice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GasPriceAdviceImplCopyWith<_$GasPriceAdviceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ClaimData _$ClaimDataFromJson(Map<String, dynamic> json) {
  return _ClaimData.fromJson(json);
}

/// @nodoc
mixin _$ClaimData {
  String get vault => throw _privateConstructorUsedError;
  String get account => throw _privateConstructorUsedError;
  String get cumulativeAmount => throw _privateConstructorUsedError;
  int get deadline => throw _privateConstructorUsedError;
  String get signature => throw _privateConstructorUsedError;

  /// Serializes this ClaimData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ClaimData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ClaimDataCopyWith<ClaimData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClaimDataCopyWith<$Res> {
  factory $ClaimDataCopyWith(ClaimData value, $Res Function(ClaimData) then) =
      _$ClaimDataCopyWithImpl<$Res, ClaimData>;
  @useResult
  $Res call(
      {String vault,
      String account,
      String cumulativeAmount,
      int deadline,
      String signature});
}

/// @nodoc
class _$ClaimDataCopyWithImpl<$Res, $Val extends ClaimData>
    implements $ClaimDataCopyWith<$Res> {
  _$ClaimDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ClaimData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vault = null,
    Object? account = null,
    Object? cumulativeAmount = null,
    Object? deadline = null,
    Object? signature = null,
  }) {
    return _then(_value.copyWith(
      vault: null == vault
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as String,
      account: null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as String,
      cumulativeAmount: null == cumulativeAmount
          ? _value.cumulativeAmount
          : cumulativeAmount // ignore: cast_nullable_to_non_nullable
              as String,
      deadline: null == deadline
          ? _value.deadline
          : deadline // ignore: cast_nullable_to_non_nullable
              as int,
      signature: null == signature
          ? _value.signature
          : signature // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ClaimDataImplCopyWith<$Res>
    implements $ClaimDataCopyWith<$Res> {
  factory _$$ClaimDataImplCopyWith(
          _$ClaimDataImpl value, $Res Function(_$ClaimDataImpl) then) =
      __$$ClaimDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String vault,
      String account,
      String cumulativeAmount,
      int deadline,
      String signature});
}

/// @nodoc
class __$$ClaimDataImplCopyWithImpl<$Res>
    extends _$ClaimDataCopyWithImpl<$Res, _$ClaimDataImpl>
    implements _$$ClaimDataImplCopyWith<$Res> {
  __$$ClaimDataImplCopyWithImpl(
      _$ClaimDataImpl _value, $Res Function(_$ClaimDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of ClaimData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vault = null,
    Object? account = null,
    Object? cumulativeAmount = null,
    Object? deadline = null,
    Object? signature = null,
  }) {
    return _then(_$ClaimDataImpl(
      vault: null == vault
          ? _value.vault
          : vault // ignore: cast_nullable_to_non_nullable
              as String,
      account: null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as String,
      cumulativeAmount: null == cumulativeAmount
          ? _value.cumulativeAmount
          : cumulativeAmount // ignore: cast_nullable_to_non_nullable
              as String,
      deadline: null == deadline
          ? _value.deadline
          : deadline // ignore: cast_nullable_to_non_nullable
              as int,
      signature: null == signature
          ? _value.signature
          : signature // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ClaimDataImpl implements _ClaimData {
  const _$ClaimDataImpl(
      {required this.vault,
      required this.account,
      required this.cumulativeAmount,
      required this.deadline,
      required this.signature});

  factory _$ClaimDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$ClaimDataImplFromJson(json);

  @override
  final String vault;
  @override
  final String account;
  @override
  final String cumulativeAmount;
  @override
  final int deadline;
  @override
  final String signature;

  @override
  String toString() {
    return 'ClaimData(vault: $vault, account: $account, cumulativeAmount: $cumulativeAmount, deadline: $deadline, signature: $signature)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClaimDataImpl &&
            (identical(other.vault, vault) || other.vault == vault) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.cumulativeAmount, cumulativeAmount) ||
                other.cumulativeAmount == cumulativeAmount) &&
            (identical(other.deadline, deadline) ||
                other.deadline == deadline) &&
            (identical(other.signature, signature) ||
                other.signature == signature));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, vault, account, cumulativeAmount, deadline, signature);

  /// Create a copy of ClaimData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ClaimDataImplCopyWith<_$ClaimDataImpl> get copyWith =>
      __$$ClaimDataImplCopyWithImpl<_$ClaimDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ClaimDataImplToJson(
      this,
    );
  }
}

abstract class _ClaimData implements ClaimData {
  const factory _ClaimData(
      {required final String vault,
      required final String account,
      required final String cumulativeAmount,
      required final int deadline,
      required final String signature}) = _$ClaimDataImpl;

  factory _ClaimData.fromJson(Map<String, dynamic> json) =
      _$ClaimDataImpl.fromJson;

  @override
  String get vault;
  @override
  String get account;
  @override
  String get cumulativeAmount;
  @override
  int get deadline;
  @override
  String get signature;

  /// Create a copy of ClaimData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ClaimDataImplCopyWith<_$ClaimDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
